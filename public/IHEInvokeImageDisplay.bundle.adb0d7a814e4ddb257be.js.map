{"version":3,"sources":["webpack:///./routes/IHEInvokeImageDisplay.js","webpack:///./customHooks/usePrevious.js","webpack:///C:/projects/Viewers/node_modules/lodash/_baseValues.js","webpack:///./connectedComponents/ViewerRetrieveStudyData.js","webpack:///./connectedComponents/ConnectedViewerRetrieveStudyData.js","webpack:///C:/projects/Viewers/node_modules/lodash/values.js"],"names":["UrlUtil","OHIF","utils","urlUtil","IHEInvokeImageDisplay","location","parse","search","requestType","studyUID","studyInstanceUIDs","split","paramString","parseParam","propTypes","PropTypes","shape","string","isRequired","withRouter","usePrevious","value","ref","useRef","useEffect","current","arrayMap","module","exports","object","props","key","OHIFStudyMetadata","metadata","OHIFSeriesMetadata","retrieveStudiesMetadata","studies","deleteStudyMetadataPromise","studyMetadataManager","makeCancelable","_promoteStudyDisplaySet","study","studyMetadata","filters","promoted","Object","keys","length","seriesInstanceUID","promotedResponse","list","searchMethod","response","index","findIndex","bind","undefined","first","splice","data","_promoteToFront","getDisplaySets","valueToCompare","displaySet","SeriesInstanceUID","displaySets","_addSeriesToStudy","series","sopClassHandlerModules","extensionManager","modules","getData","seriesMetadata","addSeries","createAndAddDisplaySetsForSeries","_updateStudyMetadataManager","StudyInstanceUID","get","add","_sortStudyDisplaySet","sortDisplaySets","ViewerRetrieveStudyData","cancelableSeriesPromises","cancelableStudiesPromises","server","seriesInstanceUIDs","clearViewportSpecificData","useState","error","setError","setStudies","isStudyLoaded","setIsStudyLoaded","snackbarContext","useSnackbarContext","useContext","AppContext","appConfig","filterQueryParam","isFilterStrategy","studyDidLoad","_promoteList","queryParamApplied","message","dialog","show","showUserMessage","_showUserMessage","applied","firstSeries","_isQueryParamApplied","processStudies","studiesData","Array","isArray","map","createDisplaySets","setDisplaySets","_updateStudyDisplaySets","seriesLoader","Promise","resolve","promisesLoaders","hasNext","push","next","then","log","all","_loadRemainingSeries","result","isCanceled","catch","loadStudies","retrieveParams","purgeCancellablePromises","cancel","remove","prevStudyInstanceUIDs","every","e","includes","purge","JSON","stringify","ConnectedViewer","array","func","redux","actions","isActive","a","active","ConnectedViewerRetrieveStudyData","connect","state","ownProps","activeServer","servers","find","dispatch","baseValues"],"mappings":"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","file":"IHEInvokeImageDisplay.bundle.adb0d7a814e4ddb257be.js","sourcesContent":["import React from 'react';\r\nimport PropTypes from 'prop-types';\r\nimport { withRouter } from 'react-router-dom';\r\nimport ConnectedViewerRetrieveStudyData from '../connectedComponents/ConnectedViewerRetrieveStudyData.js';\r\nimport OHIF from '@ohif/core';\r\nconst { urlUtil: UrlUtil } = OHIF.utils;\r\n\r\nfunction IHEInvokeImageDisplay({ location }) {\r\n  const {\r\n    // patientID,\r\n    requestType,\r\n    studyUID,\r\n  } = UrlUtil.parse(location.search);\r\n\r\n  switch (requestType) {\r\n    case 'STUDY':\r\n      return (\r\n        <ConnectedViewerRetrieveStudyData\r\n          studyInstanceUIDs={studyUID.split(';')}\r\n        />\r\n      );\r\n\r\n    case 'STUDYBASE64':\r\n      return (\r\n        <ConnectedViewerRetrieveStudyData\r\n          studyInstanceUIDs={UrlUtil.paramString.parseParam(studyUID)}\r\n        />\r\n      );\r\n\r\n    case 'PATIENT':\r\n      // TODO: connect this to the StudyList when we have the filter parameters set up\r\n      // return <StudyList patientUIDs={patientID.split(';')} />;\r\n      return '';\r\n\r\n    default:\r\n      // TODO: Figure out what to do here, this won't work because StudyList expects studies\r\n      // return <StudyList />;\r\n      return '';\r\n  }\r\n}\r\n\r\nIHEInvokeImageDisplay.propTypes = {\r\n  location: PropTypes.shape({\r\n    search: PropTypes.string,\r\n  }).isRequired,\r\n};\r\n\r\nexport default withRouter(IHEInvokeImageDisplay);\r\n","import React, { useEffect, useRef } from 'react';\r\nexport default function usePrevious(value) {\r\n  const ref = useRef();\r\n  useEffect(() => {\r\n    ref.current = value;\r\n  }, [value]);\r\n\r\n  return ref.current;\r\n}\r\n","var arrayMap = require('./_arrayMap');\n\n/**\n * The base implementation of `_.values` and `_.valuesIn` which creates an\n * array of `object` property values corresponding to the property names\n * of `props`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {Array} props The property names to get values for.\n * @returns {Object} Returns the array of property values.\n */\nfunction baseValues(object, props) {\n  return arrayMap(props, function(key) {\n    return object[key];\n  });\n}\n\nmodule.exports = baseValues;\n","import React, { useState, useEffect, useContext } from 'react';\r\nimport { metadata, studies, utils, log } from '@ohif/core';\r\nimport usePrevious from '../customHooks/usePrevious';\r\n\r\nimport ConnectedViewer from './ConnectedViewer.js';\r\nimport PropTypes from 'prop-types';\r\nimport { extensionManager } from './../App.js';\r\nimport { useSnackbarContext } from '@ohif/ui';\r\n\r\nconst { OHIFStudyMetadata, OHIFSeriesMetadata } = metadata;\r\nconst { retrieveStudiesMetadata, deleteStudyMetadataPromise } = studies;\r\nconst { studyMetadataManager, makeCancelable } = utils;\r\n\r\n// Contexts\r\nimport AppContext from '../context/AppContext';\r\n\r\nconst _promoteToFront = (list, value, searchMethod) => {\r\n  let response = [...list];\r\n  let promoted = false;\r\n  const index = response.findIndex(searchMethod.bind(undefined, value));\r\n\r\n  if (index > 0) {\r\n    const first = response.splice(index, 1);\r\n    response = [...first, ...response];\r\n  }\r\n\r\n  if (index >= 0) {\r\n    promoted = true;\r\n  }\r\n\r\n  return {\r\n    promoted,\r\n    data: response,\r\n  };\r\n};\r\n\r\n/**\r\n * Promote series to front if find found equivalent on filters object\r\n * @param {Object} study - study reference to promote series against\r\n * @param {Object} [filters] - Object containing filters to be applied\r\n * @param {string} [filter.seriesInstanceUID] - series instance uid to filter results against\r\n * @param {boolean} isFilterStrategy - if filtering by query param strategy ON\r\n */\r\nconst _promoteList = (study, studyMetadata, filters, isFilterStrategy) => {\r\n  let promoted = false;\r\n  // Promote only if no filter should be applied\r\n  if (!isFilterStrategy) {\r\n    _sortStudyDisplaySet(study, studyMetadata);\r\n    promoted = _promoteStudyDisplaySet(study, studyMetadata, filters);\r\n  }\r\n\r\n  return promoted;\r\n};\r\n\r\nconst _promoteStudyDisplaySet = (study, studyMetadata, filters) => {\r\n  let promoted = false;\r\n  const queryParamsLength = Object.keys(filters).length;\r\n  const shouldPromoteToFront = queryParamsLength > 0;\r\n\r\n  if (shouldPromoteToFront) {\r\n    const { seriesInstanceUID } = filters;\r\n\r\n    const _seriesLookup = (valueToCompare, displaySet) => {\r\n      return displaySet.SeriesInstanceUID === valueToCompare;\r\n    };\r\n    const promotedResponse = _promoteToFront(\r\n      studyMetadata.getDisplaySets(),\r\n      seriesInstanceUID,\r\n      _seriesLookup\r\n    );\r\n\r\n    study.displaySets = promotedResponse.data;\r\n    promoted = promotedResponse.promoted;\r\n  }\r\n\r\n  return promoted;\r\n};\r\n\r\n/**\r\n * Method to identify if query param (from url) was applied to given list\r\n * @param {Object} study - study reference to promote series against\r\n * @param {Object} [filters] - Object containing filters to be applied\r\n * @param {string} [filter.seriesInstanceUID] - series instance uid to filter results against\r\n * @param {boolean} isFilterStrategy - if filtering by query param strategy ON\r\n */\r\nconst _isQueryParamApplied = (study, filters = {}, isFilterStrategy) => {\r\n  const { seriesInstanceUID } = filters;\r\n  let applied = true;\r\n  // skip in case no filter or no toast manager\r\n  if (!seriesInstanceUID) {\r\n    return applied;\r\n  }\r\n\r\n  const { series = [], displaySets = [] } = study;\r\n  const firstSeries = isFilterStrategy ? series[0] : displaySets[0];\r\n\r\n  if (!firstSeries || firstSeries.SeriesInstanceUID !== seriesInstanceUID) {\r\n    applied = false;\r\n  }\r\n\r\n  return applied;\r\n};\r\nconst _showUserMessage = (queryParamApplied, message, dialog = {}) => {\r\n  if (queryParamApplied) {\r\n    return;\r\n  }\r\n\r\n  const { show: showUserMessage = () => {} } = dialog;\r\n  showUserMessage({\r\n    message,\r\n  });\r\n};\r\n\r\nconst _addSeriesToStudy = (studyMetadata, series) => {\r\n  const sopClassHandlerModules =\r\n    extensionManager.modules['sopClassHandlerModule'];\r\n  const study = studyMetadata.getData();\r\n  const seriesMetadata = new OHIFSeriesMetadata(series, study);\r\n  studyMetadata.addSeries(seriesMetadata);\r\n  studyMetadata.createAndAddDisplaySetsForSeries(\r\n    sopClassHandlerModules,\r\n    seriesMetadata,\r\n    false\r\n  );\r\n  study.displaySets = studyMetadata.getDisplaySets();\r\n  _updateStudyMetadataManager(study, studyMetadata);\r\n};\r\n\r\nconst _updateStudyMetadataManager = (study, studyMetadata) => {\r\n  const { StudyInstanceUID } = study;\r\n\r\n  if (!studyMetadataManager.get(StudyInstanceUID)) {\r\n    studyMetadataManager.add(studyMetadata);\r\n  }\r\n};\r\n\r\nconst _updateStudyDisplaySets = (study, studyMetadata) => {\r\n  const sopClassHandlerModules =\r\n    extensionManager.modules['sopClassHandlerModule'];\r\n\r\n  if (!study.displaySets) {\r\n    study.displaySets = studyMetadata.createDisplaySets(sopClassHandlerModules);\r\n  }\r\n\r\n  studyMetadata.setDisplaySets(study.displaySets);\r\n};\r\n\r\nconst _sortStudyDisplaySet = (study, studyMetadata) => {\r\n  studyMetadata.sortDisplaySets(study.displaySets);\r\n};\r\nconst _loadRemainingSeries = studyMetadata => {\r\n  const { seriesLoader } = studyMetadata.getData();\r\n  if (!seriesLoader) {\r\n    return Promise.resolve();\r\n  }\r\n  const promisesLoaders = [];\r\n  while (seriesLoader.hasNext()) {\r\n    promisesLoaders.push(\r\n      seriesLoader\r\n        .next()\r\n        .then(\r\n          series => void _addSeriesToStudy(studyMetadata, series),\r\n          error => void log.error(error)\r\n        )\r\n    );\r\n  }\r\n\r\n  return Promise.all(promisesLoaders);\r\n};\r\n\r\nfunction ViewerRetrieveStudyData({\r\n  server,\r\n  studyInstanceUIDs,\r\n  seriesInstanceUIDs,\r\n  clearViewportSpecificData,\r\n}) {\r\n  // hooks\r\n  const [error, setError] = useState(false);\r\n  const [studies, setStudies] = useState([]);\r\n  const [isStudyLoaded, setIsStudyLoaded] = useState(false);\r\n  const snackbarContext = useSnackbarContext();\r\n  const { appConfig = {} } = useContext(AppContext);\r\n  const { filterQueryParam: isFilterStrategy = false } = appConfig;\r\n\r\n  let cancelableSeriesPromises;\r\n  let cancelableStudiesPromises;\r\n  /**\r\n   * Callback method when study is totally loaded\r\n   * @param {object} study study loaded\r\n   * @param {object} studyMetadata studyMetadata for given study\r\n   * @param {Object} [filters] - Object containing filters to be applied\r\n   * @param {string} [filter.seriesInstanceUID] - series instance uid to filter results against\r\n   */\r\n  const studyDidLoad = (study, studyMetadata, filters) => {\r\n    // User message\r\n    const promoted = _promoteList(\r\n      study,\r\n      studyMetadata,\r\n      filters,\r\n      isFilterStrategy\r\n    );\r\n\r\n    // Clear viewport to allow new promoted one to be displayed\r\n    if (promoted) {\r\n      clearViewportSpecificData(0);\r\n    }\r\n\r\n    const isQueryParamApplied = _isQueryParamApplied(\r\n      study,\r\n      filters,\r\n      isFilterStrategy\r\n    );\r\n    // Show message in case not promoted neither filtered but should to\r\n    _showUserMessage(\r\n      isQueryParamApplied,\r\n      'Query parameters were not applied. Using original series list for given study.',\r\n      snackbarContext\r\n    );\r\n\r\n    setStudies([...studies, study]);\r\n    setIsStudyLoaded(true);\r\n  };\r\n\r\n  /**\r\n   * Method to process studies. It will update displaySet, studyMetadata, load remaining series, ...\r\n   * @param {Array} studiesData Array of studies retrieved from server\r\n   * @param {Object} [filters] - Object containing filters to be applied\r\n   * @param {string} [filter.seriesInstanceUID] - series instance uid to filter results against\r\n   */\r\n  const processStudies = (studiesData, filters) => {\r\n    if (Array.isArray(studiesData) && studiesData.length > 0) {\r\n      // Map studies to new format, update metadata manager?\r\n      const studies = studiesData.map(study => {\r\n        const studyMetadata = new OHIFStudyMetadata(\r\n          study,\r\n          study.StudyInstanceUID\r\n        );\r\n\r\n        _updateStudyDisplaySets(study, studyMetadata);\r\n        _updateStudyMetadataManager(study, studyMetadata);\r\n\r\n        // Attempt to load remaning series if any\r\n        cancelableSeriesPromises[study.StudyInstanceUID] = makeCancelable(\r\n          _loadRemainingSeries(studyMetadata)\r\n        )\r\n          .then(result => {\r\n            if (result && !result.isCanceled) {\r\n              studyDidLoad(study, studyMetadata, filters);\r\n            }\r\n          })\r\n          .catch(error => {\r\n            if (error && !error.isCanceled) {\r\n              setError(true);\r\n              log.error(error);\r\n            }\r\n          });\r\n\r\n        return study;\r\n      });\r\n\r\n      setStudies(studies);\r\n    }\r\n  };\r\n\r\n  const loadStudies = async () => {\r\n    try {\r\n      const filters = {};\r\n      // Use the first, discard others\r\n      const seriesInstanceUID = seriesInstanceUIDs && seriesInstanceUIDs[0];\r\n\r\n      const retrieveParams = [server, studyInstanceUIDs];\r\n\r\n      if (seriesInstanceUID) {\r\n        filters.seriesInstanceUID = seriesInstanceUID;\r\n        // Query param filtering controlled by appConfig property\r\n        if (isFilterStrategy) {\r\n          retrieveParams.push(filters);\r\n        }\r\n      }\r\n\r\n      cancelableStudiesPromises[studyInstanceUIDs] = makeCancelable(\r\n        retrieveStudiesMetadata(...retrieveParams)\r\n      )\r\n        .then(result => {\r\n          if (result && !result.isCanceled) {\r\n            processStudies(result, filters);\r\n          }\r\n        })\r\n        .catch(error => {\r\n          if (error && !error.isCanceled) {\r\n            setError(true);\r\n            log.error(error);\r\n          }\r\n        });\r\n    } catch (error) {\r\n      if (error) {\r\n        setError(true);\r\n        log.error(error);\r\n      }\r\n    }\r\n  };\r\n\r\n  const purgeCancellablePromises = () => {\r\n    for (let studyInstanceUIDs in cancelableStudiesPromises) {\r\n      if ('cancel' in cancelableStudiesPromises[studyInstanceUIDs]) {\r\n        cancelableStudiesPromises[studyInstanceUIDs].cancel();\r\n      }\r\n    }\r\n\r\n    for (let studyInstanceUIDs in cancelableSeriesPromises) {\r\n      if ('cancel' in cancelableSeriesPromises[studyInstanceUIDs]) {\r\n        cancelableSeriesPromises[studyInstanceUIDs].cancel();\r\n        deleteStudyMetadataPromise(studyInstanceUIDs);\r\n        studyMetadataManager.remove(studyInstanceUIDs);\r\n      }\r\n    }\r\n  };\r\n\r\n  const prevStudyInstanceUIDs = usePrevious(studyInstanceUIDs);\r\n\r\n  useEffect(() => {\r\n    const hasStudyInstanceUIDsChanged = !(\r\n      prevStudyInstanceUIDs &&\r\n      prevStudyInstanceUIDs.every(e => studyInstanceUIDs.includes(e))\r\n    );\r\n\r\n    if (hasStudyInstanceUIDsChanged) {\r\n      studyMetadataManager.purge();\r\n      purgeCancellablePromises();\r\n    }\r\n  }, [studyInstanceUIDs]);\r\n\r\n  useEffect(() => {\r\n    cancelableSeriesPromises = {};\r\n    cancelableStudiesPromises = {};\r\n    loadStudies();\r\n\r\n    return () => {\r\n      purgeCancellablePromises();\r\n    };\r\n  }, []);\r\n\r\n  if (error) {\r\n    return <div>Error: {JSON.stringify(error)}</div>;\r\n  }\r\n\r\n  return (\r\n    <ConnectedViewer\r\n      studies={studies}\r\n      isStudyLoaded={isStudyLoaded}\r\n      studyInstanceUIDs={studyInstanceUIDs}\r\n    />\r\n  );\r\n}\r\n\r\nViewerRetrieveStudyData.propTypes = {\r\n  studyInstanceUIDs: PropTypes.array.isRequired,\r\n  seriesInstanceUIDs: PropTypes.array,\r\n  server: PropTypes.object,\r\n  clearViewportSpecificData: PropTypes.func.isRequired,\r\n};\r\n\r\nexport default ViewerRetrieveStudyData;\r\n","import { connect } from 'react-redux';\r\nimport ViewerRetrieveStudyData from './ViewerRetrieveStudyData.js';\r\nimport OHIF from '@ohif/core';\r\n\r\nconst { clearViewportSpecificData } = OHIF.redux.actions;\r\nconst isActive = a => a.active === true;\r\n\r\nconst mapStateToProps = (state, ownProps) => {\r\n  const activeServer = state.servers.servers.find(isActive);\r\n\r\n  return {\r\n    server: ownProps.server || activeServer,\r\n  };\r\n};\r\nconst mapDispatchToProps = dispatch => {\r\n  return {\r\n    clearViewportSpecificData: () => {\r\n      dispatch(clearViewportSpecificData());\r\n    },\r\n  };\r\n};\r\n\r\nconst ConnectedViewerRetrieveStudyData = connect(\r\n  mapStateToProps,\r\n  mapDispatchToProps\r\n)(ViewerRetrieveStudyData);\r\n\r\nexport default ConnectedViewerRetrieveStudyData;\r\n","var baseValues = require('./_baseValues'),\n    keys = require('./keys');\n\n/**\n * Creates an array of the own enumerable string keyed property values of `object`.\n *\n * **Note:** Non-object values are coerced to objects.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Object\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property values.\n * @example\n *\n * function Foo() {\n *   this.a = 1;\n *   this.b = 2;\n * }\n *\n * Foo.prototype.c = 3;\n *\n * _.values(new Foo);\n * // => [1, 2] (iteration order is not guaranteed)\n *\n * _.values('hi');\n * // => ['h', 'i']\n */\nfunction values(object) {\n  return object == null ? [] : baseValues(object, keys(object));\n}\n\nmodule.exports = values;\n"],"sourceRoot":""}