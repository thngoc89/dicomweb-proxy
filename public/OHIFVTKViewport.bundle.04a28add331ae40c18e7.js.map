{"version":3,"sources":["webpack:///C:/projects/Viewers/extensions/vtk/src/VTKViewport.js","webpack:///C:/projects/Viewers/extensions/vtk/src/ConnectedVTKViewport.js","webpack:///C:/projects/Viewers/extensions/vtk/src/LoadingIndicator.js","webpack:///C:/projects/Viewers/extensions/vtk/src/OHIFVTKViewport.js"],"names":["View2D","asyncComponent","getReactVtkjsViewport","reactVtkjsViewport","default","VTKViewport","props","setViewportActiveHandler","useCallback","setViewportActive","viewportIndex","activeViewportIndex","useEffect","handleScrollEvent","evt","onScroll","uid","detail","window","addEventListener","removeEventListener","className","style","width","height","position","onClick","propTypes","PropTypes","func","isRequired","number","defaultProps","OHIF","redux","actions","setViewportSpecificData","ConnectedVTKViewport","connect","state","ownProps","dataFromStore","extensions","vtk","isActive","viewports","pluginDetails","layout","enableStackPrefetch","dispatch","data","propsFromState","propsFromDispatch","afterCreation","onCreated","api","LoadingIndicator","percComplete","this","percentComplete","Fragment","error","message","t","PureComponent","object","withTranslation","segmentationModule","cornerstoneTools","getModule","StackManager","utils","volumeCache","labelmapCache","OHIFVTKViewport","volumes","paintFilterLabelMapImageData","paintFilterBackgroundImageData","studies","StudyInstanceUID","displaySetInstanceUID","SOPClassUID","SOPInstanceUID","frameIndex","labelmapDataObject","labelmapColorLUT","stack","getCornerstoneStack","imageDataObject","getImageData","imageIds","firstImageId","brushStackState","series","activeLabelmapIndex","labelmap3D","labelmaps3D","vtkLabelmapID","labelmapBuffer","buffer","vtkImageData","newInstance","dataArray","vtkDataArray","numberOfComponents","values","Uint16Array","getPointData","setScalars","setDimensions","dimensions","setSpacing","getSpacing","setOrigin","getOrigin","setDirection","getDirection","colorLutTables","colorLUTIndex","imageMetaData0","center","Modality","undefined","lower","upper","levelsAreNotNumbers","isNaN","_getRangeFromWindowLevels","windowWidth","windowCenter","modality","volumeActor","vtkVolume","volumeMapper","vtkVolumeMapper","setMapper","setInputData","getProperty","getRGBTransferFunction","setRange","spacing","sampleDistance","setSampleDistance","setMaximumSamplesPerRay","viewportData","displaySet","sopClassUIDs","length","console","warn","study","find","dataDetails","studyDate","studyTime","studyDescription","patientName","patientId","seriesNumber","String","seriesDescription","getViewportData","getOrCreateVolume","setState","loadProgressively","setTimeout","setStateFromProps","prevProps","prevDisplaySet","loadImageData","isLoading","insertPixelDataPromises","NumberOfFrames","forEach","promise","then","numberProcessed","Math","floor","Promise","all","isLoaded","childrenWithProps","configuration","children","map","child","index","React","cloneElement","key","visible","renderFill","renderOutline","opacity","fillAlpha","outlineThickness","labelmapRenderingOptions","colorLUT","globalOpacity","log","clearStacks","displaySets","set","storedStack","findOrCreateStack","Object","assign","currentImageIdIndex","findIndex","imageId","cornerstone","metaData","get","Component","shape","array","string","arrayOf","node"],"mappings":"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","file":"OHIFVTKViewport.bundle.04a28add331ae40c18e7.js","sourcesContent":["import React, { useEffect, useCallback } from 'react';\r\n// import { View2D } from 'react-vtkjs-viewport';\r\nimport PropTypes from 'prop-types';\r\nimport asyncComponent from './asyncComponent.js';\r\nimport { getReactVtkjsViewport } from './utils/getReactVtkjsViewport';\r\n\r\nimport './VTKViewport.css';\r\n\r\nconst View2D = asyncComponent(async () => {\r\n  const reactVtkjsViewport = await getReactVtkjsViewport();\r\n  return { default: reactVtkjsViewport.View2D };\r\n});\r\n\r\nconst VTKViewport = props => {\r\n  const style = { width: '100%', height: '100%', position: 'relative' };\r\n\r\n  const setViewportActiveHandler = useCallback(() => {\r\n    const { setViewportActive, viewportIndex, activeViewportIndex } = props;\r\n\r\n    if (viewportIndex !== activeViewportIndex) {\r\n      // set in Connected\r\n      setViewportActive();\r\n    }\r\n  });\r\n\r\n  useEffect(() => {\r\n    const handleScrollEvent = evt => {\r\n      const vtkViewportApiReference = props.onScroll(props.viewportIndex) || {};\r\n      const viewportUID = vtkViewportApiReference.uid;\r\n      const viewportWasScrolled = viewportUID === evt.detail.uid;\r\n\r\n      if (viewportWasScrolled) {\r\n        setViewportActiveHandler();\r\n      }\r\n    };\r\n\r\n    window.addEventListener('vtkscrollevent', handleScrollEvent);\r\n    return () =>\r\n      window.removeEventListener('vtkscrollevent', handleScrollEvent);\r\n  }, [props, props.onScroll, props.viewportIndex, setViewportActiveHandler]);\r\n\r\n  return (\r\n    <div\r\n      className=\"vtk-viewport-handler\"\r\n      style={style}\r\n      onClick={setViewportActiveHandler}\r\n    >\r\n      <View2D {...props} />\r\n    </div>\r\n  );\r\n};\r\n\r\nVTKViewport.propTypes = {\r\n  setViewportActive: PropTypes.func.isRequired,\r\n  viewportIndex: PropTypes.number.isRequired,\r\n  activeViewportIndex: PropTypes.number.isRequired,\r\n  /* Receives viewportIndex */\r\n  onScroll: PropTypes.func,\r\n};\r\n\r\nVTKViewport.defaultProps = {\r\n  onScroll: () => { },\r\n};\r\n\r\nexport default VTKViewport;\r\n","import OHIF from '@ohif/core';\r\nimport { connect } from 'react-redux';\r\nimport VTKViewport from './VTKViewport';\r\n\r\nconst { setViewportActive, setViewportSpecificData } = OHIF.redux.actions;\r\n\r\nconst mapStateToProps = (state, ownProps) => {\r\n  let dataFromStore;\r\n\r\n  if (state.extensions && state.extensions.vtk) {\r\n    dataFromStore = state.extensions.vtk;\r\n  }\r\n\r\n  // If this is the active viewport, enable prefetching.\r\n  const { viewportIndex } = ownProps;\r\n  const isActive = viewportIndex === state.viewports.activeViewportIndex;\r\n  const viewportLayout = state.viewports.layout.viewports[viewportIndex];\r\n  const pluginDetails = viewportLayout.vtk || {};\r\n\r\n  return {\r\n    activeViewportIndex: state.viewports.activeViewportIndex,\r\n    layout: state.viewports.layout,\r\n    isActive,\r\n    ...pluginDetails,\r\n    // Hopefully this doesn't break anything under the hood for this one\r\n    // activeTool: activeButton && activeButton.command,\r\n    ...dataFromStore,\r\n    enableStackPrefetch: isActive,\r\n  };\r\n};\r\n\r\nconst mapDispatchToProps = (dispatch, ownProps) => {\r\n  const { viewportIndex } = ownProps;\r\n\r\n  return {\r\n    setViewportActive: () => {\r\n      dispatch(setViewportActive(viewportIndex));\r\n    },\r\n\r\n    setViewportSpecificData: data => {\r\n      dispatch(setViewportSpecificData(viewportIndex, data));\r\n    },\r\n  };\r\n};\r\n\r\nconst mergeProps = (propsFromState, propsFromDispatch, ownProps) => {\r\n  const { afterCreation } = propsFromState;\r\n\r\n  const props = {\r\n    ...propsFromState,\r\n    ...propsFromDispatch,\r\n    ...ownProps,\r\n    /**\r\n     * Our component sets up the underlying dom element on \"componentDidMount\"\r\n     * for use with VTK.\r\n     *\r\n     * The onCreated prop passes back an Object containing many of the internal\r\n     * components of the VTK scene. We can grab a reference to these here, to\r\n     * make playing with VTK's native methods easier.\r\n     *\r\n     * A similar approach is taken with the Cornerstone extension.\r\n     */\r\n    onCreated: api => {\r\n      // Store the API details for later\r\n      //setViewportSpecificData({ vtkApi: api });\r\n\r\n      if (afterCreation && typeof afterCreation === 'function') {\r\n        afterCreation(api);\r\n      }\r\n    },\r\n  };\r\n  return props;\r\n};\r\n\r\nconst ConnectedVTKViewport = connect(\r\n  mapStateToProps,\r\n  mapDispatchToProps,\r\n  mergeProps\r\n)(VTKViewport);\r\n\r\nexport default ConnectedVTKViewport;\r\n","import './LoadingIndicator.css';\r\n\r\nimport React, { PureComponent } from 'react';\r\nimport { withTranslation } from 'react-i18next';\r\nimport PropTypes from 'prop-types';\r\n\r\nclass LoadingIndicator extends PureComponent {\r\n  static propTypes = {\r\n    percentComplete: PropTypes.number.isRequired,\r\n    error: PropTypes.object,\r\n  };\r\n\r\n  static defaultProps = {\r\n    percentComplete: 0,\r\n    error: null,\r\n  };\r\n\r\n  render() {\r\n    let percComplete;\r\n    if (this.props.percentComplete && this.props.percentComplete !== 100) {\r\n      percComplete = `${this.props.percentComplete}%`;\r\n    }\r\n\r\n    return (\r\n      <React.Fragment>\r\n        {this.props.error ? (\r\n          <div className=\"imageViewerErrorLoadingIndicator loadingIndicator\">\r\n            <div className=\"indicatorContents\">\r\n              <h4>Error Loading Image</h4>\r\n              <p className=\"description\">An error has occurred.</p>\r\n              <p className=\"details\">{this.props.error.message}</p>\r\n            </div>\r\n          </div>\r\n        ) : (\r\n          <div className=\"imageViewerLoadingIndicator loadingIndicator\">\r\n            <div className=\"indicatorContents\">\r\n              <p>\r\n                {this.props.t('Reformatting')}...\r\n                <i className=\"fa fa-spin fa-circle-o-notch fa-fw\" />\r\n                {percComplete}\r\n              </p>\r\n            </div>\r\n          </div>\r\n        )}\r\n      </React.Fragment>\r\n    );\r\n  }\r\n}\r\n\r\nexport default withTranslation('Common')(LoadingIndicator);\r\n","import React, { Component } from 'react';\r\nimport { getReactVtkjsViewport } from './utils/getReactVtkjsViewport';\r\nimport ConnectedVTKViewport from './ConnectedVTKViewport';\r\nimport LoadingIndicator from './LoadingIndicator.js';\r\nimport OHIF from '@ohif/core';\r\nimport PropTypes from 'prop-types';\r\nimport cornerstone from 'cornerstone-core';\r\nimport cornerstoneTools from 'cornerstone-tools';\r\nimport vtkDataArray from 'vtk.js/Sources/Common/Core/DataArray';\r\nimport vtkImageData from 'vtk.js/Sources/Common/DataModel/ImageData';\r\nimport vtkVolume from 'vtk.js/Sources/Rendering/Core/Volume';\r\nimport vtkVolumeMapper from 'vtk.js/Sources/Rendering/Core/VolumeMapper';\r\n\r\nconst segmentationModule = cornerstoneTools.getModule('segmentation');\r\n\r\nconst { StackManager } = OHIF.utils;\r\n\r\n// TODO: Figure out where we plan to put this long term\r\nconst volumeCache = {};\r\nconst labelmapCache = {};\r\n\r\n/**\r\n * Create a labelmap image with the same dimensions as our background volume.\r\n *\r\n * @param backgroundImageData vtkImageData\r\n */\r\n/* TODO: Not currently used until we have drawing tools in vtkjs.\r\nfunction createLabelMapImageData(backgroundImageData) {\r\n  // TODO => Need to do something like this if we start drawing a new segmentation\r\n  // On a vtkjs viewport.\r\n\r\n  const labelMapData = vtkImageData.newInstance(\r\n    backgroundImageData.get('spacing', 'origin', 'direction')\r\n  );\r\n  labelMapData.setDimensions(backgroundImageData.getDimensions());\r\n  labelMapData.computeTransforms();\r\n\r\n  const values = new Uint8Array(backgroundImageData.getNumberOfPoints());\r\n  const dataArray = vtkDataArray.newInstance({\r\n    numberOfComponents: 1, // labelmap with single component\r\n    values,\r\n  });\r\n  labelMapData.getPointData().setScalars(dataArray);\r\n\r\n  return labelMapData;\r\n} */\r\n\r\nclass OHIFVTKViewport extends Component {\r\n  state = {\r\n    volumes: null,\r\n    paintFilterLabelMapImageData: null,\r\n    paintFilterBackgroundImageData: null,\r\n  };\r\n\r\n  static propTypes = {\r\n    viewportData: PropTypes.shape({\r\n      studies: PropTypes.array,\r\n      displaySet: PropTypes.shape({\r\n        StudyInstanceUID: PropTypes.string,\r\n        displaySetInstanceUID: PropTypes.string,\r\n        sopClassUIDs: PropTypes.arrayOf(PropTypes.string),\r\n        SOPInstanceUID: PropTypes.string,\r\n        frameIndex: PropTypes.number,\r\n      }),\r\n    }),\r\n    viewportIndex: PropTypes.number,\r\n    children: PropTypes.node,\r\n    onScroll: PropTypes.func,\r\n  };\r\n\r\n  static defaultProps = {\r\n    onScroll: () => { },\r\n  };\r\n\r\n  static id = 'OHIFVTKViewport';\r\n\r\n  static init() {\r\n    console.log('OHIFVTKViewport init()');\r\n  }\r\n\r\n  static destroy() {\r\n    console.log('OHIFVTKViewport destroy()');\r\n    StackManager.clearStacks();\r\n  }\r\n\r\n  static getCornerstoneStack(\r\n    studies,\r\n    StudyInstanceUID,\r\n    displaySetInstanceUID,\r\n    SOPInstanceUID,\r\n    frameIndex\r\n  ) {\r\n    // Create shortcut to displaySet\r\n    const study = studies.find(\r\n      study => study.StudyInstanceUID === StudyInstanceUID\r\n    );\r\n\r\n    const displaySet = study.displaySets.find(set => {\r\n      return set.displaySetInstanceUID === displaySetInstanceUID;\r\n    });\r\n\r\n    // Get stack from Stack Manager\r\n    const storedStack = StackManager.findOrCreateStack(study, displaySet);\r\n\r\n    // Clone the stack here so we don't mutate it\r\n    const stack = Object.assign({}, storedStack);\r\n\r\n    if (frameIndex !== undefined) {\r\n      stack.currentImageIdIndex = frameIndex;\r\n    } else if (SOPInstanceUID) {\r\n      const index = stack.imageIds.findIndex(imageId => {\r\n        const imageIdSOPInstanceUID = cornerstone.metaData.get(\r\n          'SOPInstanceUID',\r\n          imageId\r\n        );\r\n\r\n        return imageIdSOPInstanceUID === SOPInstanceUID;\r\n      });\r\n\r\n      if (index > -1) {\r\n        stack.currentImageIdIndex = index;\r\n      }\r\n    } else {\r\n      stack.currentImageIdIndex = 0;\r\n    }\r\n\r\n    return stack;\r\n  }\r\n\r\n  getViewportData = (\r\n    studies,\r\n    StudyInstanceUID,\r\n    displaySetInstanceUID,\r\n    SOPClassUID,\r\n    SOPInstanceUID,\r\n    frameIndex,\r\n    reactVtkjsViewport\r\n  ) => {\r\n    const stack = OHIFVTKViewport.getCornerstoneStack(\r\n      studies,\r\n      StudyInstanceUID,\r\n      displaySetInstanceUID,\r\n      SOPClassUID,\r\n      SOPInstanceUID,\r\n      frameIndex\r\n    );\r\n\r\n    const imageDataObject = reactVtkjsViewport.getImageData(\r\n      stack.imageIds,\r\n      displaySetInstanceUID\r\n    );\r\n    let labelmapDataObject;\r\n    let labelmapColorLUT;\r\n\r\n    const firstImageId = stack.imageIds[0];\r\n    const { state } = segmentationModule;\r\n    const brushStackState = state.series[firstImageId];\r\n\r\n    if (brushStackState) {\r\n      const { activeLabelmapIndex } = brushStackState;\r\n      const labelmap3D = brushStackState.labelmaps3D[activeLabelmapIndex];\r\n\r\n      const vtkLabelmapID = `${firstImageId}_${activeLabelmapIndex}`;\r\n\r\n      if (labelmapCache[vtkLabelmapID]) {\r\n        labelmapDataObject = labelmapCache[vtkLabelmapID];\r\n      } else {\r\n        // TODO -> We need an imageId based getter in cornerstoneTools\r\n        const labelmapBuffer = labelmap3D.buffer;\r\n\r\n        // Create VTK Image Data with buffer as input\r\n        labelmapDataObject = vtkImageData.newInstance();\r\n\r\n        const dataArray = vtkDataArray.newInstance({\r\n          numberOfComponents: 1, // labelmap with single component\r\n          values: new Uint16Array(labelmapBuffer),\r\n        });\r\n\r\n        labelmapDataObject.getPointData().setScalars(dataArray);\r\n        labelmapDataObject.setDimensions(...imageDataObject.dimensions);\r\n        labelmapDataObject.setSpacing(\r\n          ...imageDataObject.vtkImageData.getSpacing()\r\n        );\r\n        labelmapDataObject.setOrigin(\r\n          ...imageDataObject.vtkImageData.getOrigin()\r\n        );\r\n        labelmapDataObject.setDirection(\r\n          ...imageDataObject.vtkImageData.getDirection()\r\n        );\r\n\r\n        // Cache the labelmap volume.\r\n        labelmapCache[vtkLabelmapID] = labelmapDataObject;\r\n      }\r\n\r\n      labelmapColorLUT = state.colorLutTables[labelmap3D.colorLUTIndex];\r\n    }\r\n\r\n    return {\r\n      imageDataObject,\r\n      labelmapDataObject,\r\n      labelmapColorLUT,\r\n    };\r\n  };\r\n\r\n  /**\r\n   *\r\n   *\r\n   * @param {object} imageDataObject\r\n   * @param {object} imageDataObject.vtkImageData\r\n   * @param {object} imageDataObject.imageMetaData0\r\n   * @param {number} [imageDataObject.imageMetaData0.WindowWidth] - The volume's initial WindowWidth\r\n   * @param {number} [imageDataObject.imageMetaData0.WindowCenter] - The volume's initial WindowCenter\r\n   * @param {string} imageDataObject.imageMetaData0.Modality - CT, MR, PT, etc\r\n   * @param {string} displaySetInstanceUID\r\n   * @returns vtkVolumeActor\r\n   * @memberof OHIFVTKViewport\r\n   */\r\n  getOrCreateVolume(imageDataObject, displaySetInstanceUID) {\r\n    if (volumeCache[displaySetInstanceUID]) {\r\n      return volumeCache[displaySetInstanceUID];\r\n    }\r\n\r\n    const { vtkImageData, imageMetaData0 } = imageDataObject;\r\n    // TODO -> Should update react-vtkjs-viewport and react-cornerstone-viewports\r\n    // internals to use naturalized DICOM JSON names.\r\n    const {\r\n      windowWidth: WindowWidth,\r\n      windowCenter: WindowCenter,\r\n      modality: Modality,\r\n    } = imageMetaData0;\r\n\r\n    const { lower, upper } = _getRangeFromWindowLevels(\r\n      WindowWidth,\r\n      WindowCenter,\r\n      Modality\r\n    );\r\n    const volumeActor = vtkVolume.newInstance();\r\n    const volumeMapper = vtkVolumeMapper.newInstance();\r\n\r\n    volumeActor.setMapper(volumeMapper);\r\n    volumeMapper.setInputData(vtkImageData);\r\n\r\n    volumeActor\r\n      .getProperty()\r\n      .getRGBTransferFunction(0)\r\n      .setRange(lower, upper);\r\n\r\n    const spacing = vtkImageData.getSpacing();\r\n    // Set the sample distance to half the mean length of one side. This is where the divide by 6 comes from.\r\n    // https://github.com/Kitware/VTK/blob/6b559c65bb90614fb02eb6d1b9e3f0fca3fe4b0b/Rendering/VolumeOpenGL2/vtkSmartVolumeMapper.cxx#L344\r\n    const sampleDistance = (spacing[0] + spacing[1] + spacing[2]) / 6;\r\n\r\n    volumeMapper.setSampleDistance(sampleDistance);\r\n\r\n    // Be generous to surpress warnings, as the logging really hurts performance.\r\n    // TODO: maybe we should auto adjust samples to 1000.\r\n    volumeMapper.setMaximumSamplesPerRay(4000);\r\n\r\n    volumeCache[displaySetInstanceUID] = volumeActor;\r\n\r\n    return volumeActor;\r\n  }\r\n\r\n  async setStateFromProps() {\r\n    const reactVtkjsViewport = await getReactVtkjsViewport();\r\n\r\n    const { studies, displaySet } = this.props.viewportData;\r\n    const {\r\n      StudyInstanceUID,\r\n      displaySetInstanceUID,\r\n      sopClassUIDs,\r\n      SOPInstanceUID,\r\n      frameIndex,\r\n    } = displaySet;\r\n\r\n    if (sopClassUIDs.length > 1) {\r\n      console.warn(\r\n        'More than one SOPClassUID in the same series is not yet supported.'\r\n      );\r\n    }\r\n\r\n    const study = studies.find(\r\n      study => study.StudyInstanceUID === StudyInstanceUID\r\n    );\r\n\r\n    const dataDetails = {\r\n      studyDate: study.studyDate,\r\n      studyTime: study.studyTime,\r\n      studyDescription: study.studyDescription,\r\n      patientName: study.patientName,\r\n      patientId: study.patientId,\r\n      seriesNumber: String(displaySet.seriesNumber),\r\n      seriesDescription: displaySet.seriesDescription,\r\n    };\r\n\r\n    const {\r\n      imageDataObject,\r\n      labelmapDataObject,\r\n      labelmapColorLUT,\r\n    } = this.getViewportData(\r\n      studies,\r\n      StudyInstanceUID,\r\n      displaySetInstanceUID,\r\n      sopClassUIDs[0],\r\n      SOPInstanceUID,\r\n      frameIndex,\r\n      reactVtkjsViewport\r\n    );\r\n\r\n    this.imageDataObject = imageDataObject;\r\n\r\n    /* TODO: Not currently used until we have drawing tools in vtkjs.\r\n    if (!labelmap) {\r\n      labelmap = createLabelMapImageData(data);\r\n    } */\r\n\r\n    const volumeActor = this.getOrCreateVolume(\r\n      imageDataObject,\r\n      displaySetInstanceUID\r\n    );\r\n\r\n    this.setState(\r\n      {\r\n        percentComplete: 0,\r\n        dataDetails,\r\n      },\r\n      () => {\r\n        this.loadProgressively(imageDataObject, reactVtkjsViewport);\r\n\r\n        // TODO: There must be a better way to do this.\r\n        // We do this so that if all the data is available the react-vtkjs-viewport\r\n        // Will render _something_ before the volumes are set and the volume\r\n        // Construction that happens in react-vtkjs-viewport locks up the CPU.\r\n        setTimeout(() => {\r\n          this.setState({\r\n            volumes: [volumeActor],\r\n            paintFilterLabelMapImageData: labelmapDataObject,\r\n            paintFilterBackgroundImageData: imageDataObject.vtkImageData,\r\n            labelmapColorLUT,\r\n          });\r\n        }, 200);\r\n      }\r\n    );\r\n  }\r\n\r\n  async componentDidMount() {\r\n    await this.setStateFromProps();\r\n  }\r\n\r\n  async componentDidUpdate(prevProps) {\r\n    const { displaySet } = this.props.viewportData;\r\n    const prevDisplaySet = prevProps.viewportData.displaySet;\r\n\r\n    if (\r\n      displaySet.displaySetInstanceUID !==\r\n      prevDisplaySet.displaySetInstanceUID ||\r\n      displaySet.SOPInstanceUID !== prevDisplaySet.SOPInstanceUID ||\r\n      displaySet.frameIndex !== prevDisplaySet.frameIndex\r\n    ) {\r\n      await this.setStateFromProps();\r\n    }\r\n  }\r\n\r\n  loadProgressively(imageDataObject, reactVtkjsViewport) {\r\n    reactVtkjsViewport.loadImageData(imageDataObject);\r\n\r\n    const { isLoading, insertPixelDataPromises } = imageDataObject;\r\n\r\n    const NumberOfFrames = insertPixelDataPromises.length;\r\n\r\n    if (!isLoading) {\r\n      this.setState({ isLoaded: true });\r\n      return;\r\n    }\r\n\r\n    insertPixelDataPromises.forEach(promise => {\r\n      promise.then(numberProcessed => {\r\n        const percentComplete = Math.floor(\r\n          (numberProcessed * 100) / NumberOfFrames\r\n        );\r\n\r\n        if (percentComplete !== this.state.percentComplete) {\r\n          this.setState({\r\n            percentComplete,\r\n          });\r\n        }\r\n      });\r\n    });\r\n\r\n    Promise.all(insertPixelDataPromises).then(() => {\r\n      this.setState({\r\n        isLoaded: true,\r\n      });\r\n    });\r\n  }\r\n\r\n  render() {\r\n    let childrenWithProps = null;\r\n    const { configuration } = segmentationModule;\r\n\r\n    // TODO: Does it make more sense to use Context?\r\n    if (this.props.children && this.props.children.length) {\r\n      childrenWithProps = this.props.children.map((child, index) => {\r\n        return (\r\n          child &&\r\n          React.cloneElement(child, {\r\n            viewportIndex: this.props.viewportIndex,\r\n            key: index,\r\n          })\r\n        );\r\n      });\r\n    }\r\n\r\n    const style = { width: '100%', height: '100%', position: 'relative' };\r\n\r\n    const visible = configuration.renderFill || configuration.renderOutline;\r\n    const opacity = configuration.fillAlpha;\r\n    const outlineThickness = configuration.outlineThickness;\r\n\r\n    return (\r\n      <>\r\n        <div style={style}>\r\n          {!this.state.isLoaded && (\r\n            <LoadingIndicator percentComplete={this.state.percentComplete} />\r\n          )}\r\n          {this.state.volumes && (\r\n            <ConnectedVTKViewport\r\n              volumes={this.state.volumes}\r\n              paintFilterLabelMapImageData={\r\n                this.state.paintFilterLabelMapImageData\r\n              }\r\n              paintFilterBackgroundImageData={\r\n                this.state.paintFilterBackgroundImageData\r\n              }\r\n              viewportIndex={this.props.viewportIndex}\r\n              dataDetails={this.state.dataDetails}\r\n              labelmapRenderingOptions={{\r\n                colorLUT: this.state.labelmapColorLUT,\r\n                globalOpacity: opacity,\r\n                visible,\r\n                outlineThickness,\r\n                renderOutline: true,\r\n              }}\r\n              onScroll={this.props.onScroll}\r\n            />\r\n          )}\r\n        </div>\r\n        )}\r\n        {childrenWithProps}\r\n      </>\r\n    );\r\n  }\r\n}\r\n\r\n/**\r\n * Takes window levels and converts them to a range (lower/upper)\r\n * for use with VTK RGBTransferFunction\r\n *\r\n * @private\r\n * @param {number} [width] - the width of our window\r\n * @param {number} [center] - the center of our window\r\n * @param {string} [Modality] - 'PT', 'CT', etc.\r\n * @returns { lower, upper } - range\r\n */\r\nfunction _getRangeFromWindowLevels(width, center, Modality = undefined) {\r\n  // For PET just set the range to 0-5 SUV\r\n  if (Modality === 'PT') {\r\n    return { lower: 0, upper: 5 };\r\n  }\r\n\r\n  const levelsAreNotNumbers = isNaN(center) || isNaN(width);\r\n\r\n  if (levelsAreNotNumbers) {\r\n    return { lower: 0, upper: 512 };\r\n  }\r\n\r\n  return {\r\n    lower: center - width / 2.0,\r\n    upper: center + width / 2.0,\r\n  };\r\n}\r\n\r\nexport default OHIFVTKViewport;\r\n"],"sourceRoot":""}